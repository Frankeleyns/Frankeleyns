---
title: 成功日记（二十二）
date: 2020-11-8 18:32:17
tags: 成功日记
index_img: https://i.loli.net/2020/05/14/nbsRNlMKUdCDfyP.png
banner_img: https://i.loli.net/2020/05/14/nbsRNlMKUdCDfyP.png
---





# 成功日记（二十二）



## 《自控力》

#### 阅读章节：第五章 大脑的弥天大谎—为什么我们误把渴望当幸福？

**R：原文摘抄**

​		手机、互联网和其他社交媒体可能无意中激活了我们的奖励系统，当电脑和电子游戏设计者是有意识地控制人们的奖励系统，让玩家上钩。“升级”和“获胜"随时可能出现，游戏就这样激发了人们的兴趣。这也是人们很难戒掉游戏的原因。一项研究发现，电子游戏刺激和使用苯丙胺时产生的多巴胺一样多。正是这种多巴胺的增加使人们会对这两种东西上瘾。具有不确定性的”得分“和”升级“会让你的多巴胺神经元不停燃烧，让你像被粘在椅子上一样。

**I：阅读理解**

​		奖励系统是大脑中的一块神经区域，曾经有一些可怜小白鼠被科学家在脑中这块区域植入了一个电极，然后还放置了一个按钮在这些小白鼠面前，只要它们去按那个按钮，它们的奖励系统就会受到电击刺激。当小白鼠发现了这个按钮的作用，就会每5秒电击自己一次。然而这样它们还不满足，它们会一直不停的按，直到力竭而亡。电子游戏中的**获胜**与**升级**就会触发我们的奖励系统，使我们分泌多巴胺感到暂时的愉悦，电子游戏的刺激程度和苯丙胺一样。什么是苯丙胺呢？它有个俗称叫**冰毒**。

**A1：自己经验**

​		我是个对游戏上瘾的人，尤其是**英雄联盟**，游戏为什么好玩呢?因为当你赢了对面的那一刻大脑会产生很多的多巴胺，让我心情愉悦，就是这种感觉让我堕落、让我成谜、让我下坠。类似的还有抖音、微博、微信、B站，这些产品就是植入我们脑子中的电极，滑动手指的我们就像那笼中可怜的小白鼠想再次感受一次电击一样，追寻着没有意义的奖励，直到最终迷失自己。

**A2：运用实践**

​		看到这章突然感觉互联网这个东西是把锋利的双刃剑，给我们带来便利的同时又深深的控制着我们。我要控制自己玩游戏的频率，周一至周五是我上班与学习的时间，禁止自己玩游戏，周末要写成功日记，写了才可以玩。





## 《经济学原理》

#### 阅读章节：第十五章 垄断

**垄断：**如果一个企业是其产品唯一的卖者，而且如果其产品并没有相近的替代品，这个企业就算垄断。

**进入障碍：**垄断者能在其市场上保持唯一卖者的地位，其他企业不能进入市场与之竞争。

进入障碍三个因素：

- 关键资源由一家企业拥有。

  例如：De Beers，经营全球十九个钻石矿，生产全球逾半数的钻石，“钻石恒久远，一颗永流传” 就是它们的广告

- 政府基于一个企业排他性地生产某种产品的权力。

  例如：中石油，中国电网，国企基本都是政府赋予排他权力

- 生产成本使一个生产者比大量生产者更有效率。

**自然垄断：**当一个企业能以低于两个或更多企业的成本为整个市场供给一种物品或劳务时，这个行业是自然垄断。

**价格歧视：**企业把同一种物品不同价格卖给不同顾客，这种做法成为价格歧视。

例如：车站买票，大人全额购买，小朋友半价。



## 《穷查理宝典》

#### 阅读章节：第十讲

**R：原文摘抄**

​		要得到你想要的某样东西，最可靠的办法是让你自己配得起它。这是个十分简单的道理，是黄金法则。你们要学会己所不欲，勿施于人。在我看来，无论是对律师还是对其他人来说，这都是他们最应该有的精神。总的来说，拥有这种精神的人在生活中能够赢得许多东西。他们赢得的不只是金钱和名誉。他们还赢得尊敬，理所当然地赢得与他们打交道的人的信任。能够赢得别人的信任是非常快乐的事情。

**I：阅读理解**

​		要想得到某样超出自己当前能力范围的东西，就需要想办法努力提升自己的能力和价值，直到自己配的上它。有这种想法的人都是生活中的强者，他们名利双收；他们令人尊敬；他们为人可靠，深得别人的信任。

**A1：自己经历**

​		因为我的厚脸皮，加过一些我觉得很优秀的人微信，想着和别人做好朋友，以为这样就算是有了自己的人脉，但其实这样的朋友只是有别人的联系方式而已，最多算是朋友圈的“点赞之交”，甚至对方加完都忘了你是谁，对于交友的目的根本没有任何帮助。因为你和别人段位根本不平等，人家在钻石，你只是个白银，阶层不同，家庭环境不同，三观不同，根本不可能聊的火热。

**A2：运用实践**

​		想要和优秀人结识，首先要提升自己的能力和价值，让自己的段位提升到和对方平起平坐，这样有机会自然可以结识得到。就算我有幸和小马哥(Pony马)同桌恰饭，最多也就是拍个照炫耀一下，对实际工作和个人发展没什么帮助，但如果我是某个领域的专家，我的能力刚好是小马哥需要的，到时候他自然会来找我合作（又开始做白日梦了）。

![PonyMa1.jpg](https://i.loli.net/2020/11/07/DCnIKJWGQEfOems.jpg)





## JAVA小技巧

#### 复合优于继承

​		继承（extends）是实现代码重用的有力手段，但它并非永远是完成这项工作的最佳工具。使用不当会导致应用变的脆弱。下面我举一个例子，我需要查询**HashSet**看看它被创建以来添加过多少个元素。为了实现该功能，我会继承该类，增加一个**addCount**属性来记录元素插入数量，还有一个访问该数值的方法，并覆盖**add**、**addAll**这两个增加元素的方法。

```java
//Broken - inappropriate use of inheritance!
public class InstrumentedHashSet<E> extends HashSet<E> {
    //The number of attempted element insertions
    private int addCount = 0;

    public InstrumentedHashSet(){}

    public InstrumentedHashSet(int initCap, float loadFactor){
        super(initCap,loadFactor);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getCount(){
        return addCount;
    }
}
```

然后，创建一个实例运行试试：

```java
    public static void main(String[] args) {
        List<String> list = Arrays.asList("Snap", "Crackle", "Pop");
        InstrumentedHashSet<String> ihashSert = new InstrumentedHashSet<String>();
        ihashSert.addAll(list);
        System.out.println(ihashSert.getCount());	//输出： 6
    }
```

我只添加了3个元素，然而实际结果却返回6，为什么呢？请看下面的**HashSet**的**addAll**方法的实现：

```java
    public boolean addAll(Collection<? extends E> c) {
        boolean modified = false;
        for (E e : c)
            if (add(e))		//调用add方法
                modified = true;
        return modified;
    }
```

原来**HashSet**的**addAll**方法是基于**add**方法来实现的，但这在它的文档里并没有说明（感觉这不是成功日记这是踩坑日记），我们**InstrumentedHashSet**类中的**addAll**方法，首先给**addCount**增加3，然后当进入**super.addAll**来调用**HashSet**的**addAll**实现的时候，Bug出现了，这时又会调用三次add方法，每个元素调用一次，给**addCount**又增加了3，所以总共增加了6。

下面我们使用**复合（composition）**来解决这个继承产生的坑。

```java
//Wrapper class - uses composition in place of extends
public class ForwardingSet<E> implements Set<E> {

    private final Set<E> s;

    public ForwardingSet(Set<E> s) {
        this.s = s;
    }

    @Override
    public void clear() {
        s.clear();
    }

    @Override
    public int size() {
        return s.size();
    }

    @Override
    public boolean isEmpty() {
        return s.isEmpty();
    }

    @Override
    public boolean contains(Object o) {
        return s.contains(o);
    }

    @Override
    public Iterator<E> iterator() {
        return s.iterator();
    }

    @Override
    public Object[] toArray() {
        return s.toArray();
    }

    @Override
    public <T> T[] toArray(T[] a) {
        return s.toArray(a);
    }

    @Override
    public boolean add(E e) {
        return s.add(e);
    }

    @Override
    public boolean remove(Object o) {
        return s.remove(o);
    }

    @Override
    public boolean containsAll(Collection<?> c) {
        return s.containsAll(c);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        return s.addAll(c);
    }

    @Override
    public boolean retainAll(Collection<?> c) {
        return s.retainAll(c);
    }

    @Override
    public boolean removeAll(Collection<?> c) {
        return s.removeAll(c);
    }

}
```

```java
//Reusable forwarding class
public class InstrumentedSet<E> extends ForwardingSet<E>{

    private int addCount = 0;

    public InstrumentedSet(Set<E> s) {
        super(s);
    }

    @Override
    public boolean add(E e) {
        addCount++;
        return super.add(e);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount(){
        return addCount;
    }
}
```

创建实例测试一下：

```java
    public static void main(String[] args) {
        List<String> list = Arrays.asList("Snap", "Crackle", "Pop");
        InstrumentedSet<String> s = new InstrumentedSet<>(new HashSet<>());
        s.addAll(list);
        System.out.println(s.getAddCount());	//输出： 3
    }
```

**ForwardingSet**类中的每个实例方法都可以调用被包含的现有类**Set**实例中的对应方法，并返回它的结果，这被称为转发（forwarding），**ForwardingSet**中的方法被称为**转发方法(forwarding method)**，这样得到的方法非常稳固，不依赖于现有类的实现细节，所以就不会出现像继承**HashSet**时的Bug。





## Keep

**√打卡**

![Keep.jpg](https://i.loli.net/2020/11/07/vwaihlWdmXRKq3o.jpg)
