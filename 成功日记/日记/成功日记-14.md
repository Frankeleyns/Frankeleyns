---
title: 成功日记（十四）
date: 2020-8-22 18:00:17
tags: 成功日记
index_img: https://i.loli.net/2020/05/14/nbsRNlMKUdCDfyP.png
banner_img: https://i.loli.net/2020/05/14/nbsRNlMKUdCDfyP.png
---



# 成功日记（十四）

## 《穷查理宝典》

已看到查理十一讲中的 **第二讲 论基本的、普世的智慧，及其与投资管理和商业的关系**

#### 要掌握多种思维模型

可以理解为用多学科的方式来理解事物，如果你只会一两个，你看问题将会扭曲现实，有句谚语**”在在手里拿着铁锤的人看来，任何问题都像钉子“**。

下面是文中有具体提出过的思维模型

**复利原理**、**排列组合原理**、**工程学类的思维模型（断裂点原则）**、**生物学/生理学模型**、**心理学模型（误判心理学）**、**微观经济学**

其中只有**微观经济学**和**心理学**的书我看过一点，剩下其他的基本没怎么接触过，学海无涯，这么多模型怕是有的学了，有目标总比无头苍蝇好。

#### 伯克希尔哈撒韦的投资哲学

**伯克希尔哈撒韦不投高科技行业**，查理表示很难理解高科技、芯片等行业发展的实质。高科技行业的改朝换代非常快，像苹果和诺基亚，原本诺基亚已经统治了手机市场，结果乔布斯的苹果一发布，直接把诺基亚拉下神坛。巴菲特不投高科技行业的原因，有一部分可能是因为高科技行业这种颠覆性。

**将股市比作赛马场**，股票的未来的回报率相当于赛马赌博的赔率，他们会仔细的分析，看哪只**“马”**的赔率高，等待机会然后下重注，其他时间则按兵不动。

**伯克希尔哈撒韦喜欢投资优质企业**，他们的绝大部分利润都是通过这个方式来实现的。在一些伟大的企业还没成长起来的时候及早的发现，他们会去关注哪些企业拥有优秀的管理人员，**因为管理人员很重要。**





## 《经济学原理》

进度：**第七章 消费者、生产者与市场效率**

- **支付意愿**：一个人愿意为某件商品支付的最高价格，称为 支付意愿

- **消费者剩余**：消费者剩余 是买者支付意愿价格 减去 实际付出的钱

  **消费者剩余 = 买者的评估价格 - 买者支付的价格**

  例子： 你为了偶像的演唱会门票愿意出1000￥，你买门票的价格为800￥，那你就得到了200￥的消费者剩余

消费者剩余是衡量消费者从一种物品中得到了多少**效用**，是一种买者自己才能感觉到的收益。

- **生产者剩余**： 卖者得到的价格家减去生产成本。

  **生产者剩余 = 卖者得到的价格 - 卖者的成本**

  例子：你愿意以100￥的价格去从事保安这个工作，但这份工作的工资为200￥，你就得到了100￥的生产者剩余。

- **总剩余：**要衡量社会经济福利，就是消费者剩余和生产者剩余的总和

  **总剩余 = 买者的评估价格 - 买者的支付价格 + 卖者得到的价格 - 卖者的成本**

  因为，买者支付的价格就等于卖者得到的价格，所以相互抵消，结果就是：

  **总剩余 = 买者的评估价格 - 卖者的成本**

消费者剩余可以用 **需求曲线 ** 表示，生产者剩余可以用 **供给曲线** 表示

市场会把供给分配给那些评估价格高的买者，市场也会把需求分配给那些生产成本低的卖者。

所以说，市场通常可以让资源得到最优配置，它就是亚当·斯密说的"看不见的手"。

但有时候也会发生**市场失灵**的情况：

- **市场势力：**也就是垄断，当市场中只有一家企业时，这家企业可以任意定价造成市场失灵
- **外部性：**环境污染，导致别人的市场利益受到损害，这个时候的政府政策就可以开始行动了





## 《自控力》

<div align="center">
<img src="https://i.loli.net/2020/08/23/ciXvYLIulk6GaHo.png">=
</div>

**第一章 我要做，我不要，我想要**

一般说到意志力，大部分人估计都会想到拒绝诱惑，拒绝蛋糕，拒绝高卡路里的炸鸡或是拒绝香烟之类的。这就是**"我不要"**。

但意志力不只是一味的说**"我不"**，除了说不，你还得学会说**"我要"**，减肥，学习这些事情也是需要意志力的，这就是**"我要做"**。

**“我不要”**和**“我要做”**是自控的两种表现，但不是全部。要权衡如何在**需要"说不"时”说不“，需要”说要“时”说要“**，还需要第三种因素，就是**我想要**，这个我想要不是我想要一只炸鸡，想要吃巧克力蛋糕。但你真正想要的其实是，赚更多的钱、变得更苗条、变得更优秀。这些事情才是你真正的目标，关键时刻明确自己的目标，这就是**”我想要“**。

书中提到一种训练意志力方法——**五分钟冥想**。

1. 原地不动，安静做好

2. 注意自己的呼吸

   吸气时脑中默念**"吸"**，呼气时脑中默念**”呼“**

3. 感受呼吸，弄清自己是怎么走神的

   几分钟后，可以不再默念”呼“ ”吸“。这时你可能更容易走神，当你发现自己想别的事情时，很难集中注意力，可以重新在脑中默念 ”呼“ ”吸“，这样可以锻炼自我意识和自控力。






## JAVA小技巧

**注意过期的对象引用**

Java比C好用的地方，就是java有**GC**，不用的对象系统会自动帮你回收，不用像C用完还要自己手动**free**。这方便了程序员们工作，但你不能认为你不用考虑**内存管理**的事情。

看一下用java实现简单的栈：

```java
public class Stack {
    private Object[] elements;
    private int top = 0;
    private static final int DEFAULT_INITIAL_CAPACITY = 3;

    public Stack(){
        elements = new Object[DEFAULT_INITIAL_CAPACITY];
    }

    public void push(Object e){
        ensureCapacity();
        elements[top++] = e;
    }

    public Object pop(){
        if(top == 0)
            throw new EmptyStackException();
        Object result = elements[--top];
        return result;
    }

    /**
     *  保证每次新增元素都有足够空间
     */
    private void ensureCapacity(){
        if(elements.length == top)
            elements = Arrays.copyOf(elements,2 * top + 1);
    }

}
```

这样写看起来好像没啥问题，但是当你调用的时候就发现——靠北，问题大了！

```java
        Stack stack = new Stack();
        stack.push("a"); 
        stack.push("b");
        stack.pop();
        stack.pop();
输出：
	Stack{elements=[a, null, null], top=1}
	Stack{elements=[a, b, null], top=2}
	Stack{elements=[a, b, null], top=1}
	Stack{elements=[a, b, null], top=0}
```

你会发现**pop()**不起作用，我明明不用这个对象了，为啥java不把他回收呢？那是因为栈内部维护着这些对象的**过期引用(obsolete reference)**，而过期引用是永远不会被回收的。

因为你的Stack类是自己管理着内存，开发人员知道，**elements**里数组下标**小于top**的对象重要，其余的需要回收，但是垃圾回收器不懂，他认为整个**elements**里的元素都是一视同仁的，都是有用的。于是就造成了**过期引用**，**只要是类自己管理内存，程序员就要警惕内存泄漏问题。**

解决的办法也很简单就是**手动清空**。

```java
    public Object pop(){
        if(top == 0)
            throw new EmptyStackException();
        Object result = elements[--top];
        elements[top] = null; /* 手动清空 */
        return result;
    }
```

因为JDK也有Stack类,所以我去翻了翻JDK**java.util.Stack**的源码，看看它是怎么做的，下面是JDK的Stack类的pop方法：

```java
    public synchronized E pop() {
        E       obj;
        int     len = size();

        obj = peek();
        removeElementAt(len - 1);

        return obj;
    }
```

这里面调用了一个**removeElementAt()**方法，这是**java.util.Vector**的方法，而JDK里的Stack类继承自**Vector**类，进去**Vector.removeElementAt()**你就会看见下面这句话：

```java
        elementData[elementCount] = null; /* to let gc do its work */
```

原来JDK的Stack也是用的手动清空的方式来回收内存！





## Keep

**√**打卡

<div align="center">
	<img src="https://i.loli.net/2020/08/22/2WgnejqFudKlYOQ.jpg">
</div>